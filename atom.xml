<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luoxiaohei🥝</title>
  
  
  <link href="https://qzl.luoxiaohei.fun/atom.xml" rel="self"/>
  
  <link href="https://qzl.luoxiaohei.fun/"/>
  <updated>2023-06-07T03:00:16.578Z</updated>
  <id>https://qzl.luoxiaohei.fun/</id>
  
  <author>
    <name>luoxiaohei🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用局域网实现iphone和windows文件互传||不再使用qq微信传文件</title>
    <link href="https://qzl.luoxiaohei.fun/posts/a89916b1.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/a89916b1.html</id>
    <published>2023-06-07T02:41:42.750Z</published>
    <updated>2023-06-07T03:00:16.578Z</updated>
    
    <content type="html"><![CDATA[<p>遇到的bug：</p><h1>内容不可用无法显示文件夹内容</h1><p>出错原因是啥不知道</p><p>解决办法：删除链接的服务器然后重新连接。</p><p>共享文件夹方法：</p><h6 id="1、在-Windows-电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。">1、在 Windows 电脑新建一个文件夹，右击「属性」，选择「共享」选项卡。</h6><p><img src="https://pic4.zhimg.com/80/v2-712d2769bf193c7a3b92f5639ba6d2d7_720w.jpg" alt="img"></p><h6 id="2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」">2、点击「高级共享」，在弹出窗口中勾选「共享此文件夹」，点击「权限」</h6><p><img src="https://pic1.zhimg.com/80/v2-669f23527c738dd93f23f6bb82967568_720w.jpg" alt="img"></p><p>3、在新打开的「权限」窗口中选中 「Everyone」，在「Everyone」下方勾选「完全控制」选项。</p><p><img src="https://pic4.zhimg.com/80/v2-131545f3e481709230b2b2d74fc8a2a7_720w.jpg" alt="img"></p><p>4、回到最开始的「属性」窗口，点击「共享」，在弹出的「网络访问」窗口，选择「Everyone」后，点击「添加」。</p><p><img src="https://pic4.zhimg.com/80/v2-2e4f68e3b5d0a93cd4923305520b2aef_720w.jpg" alt="img"></p><p>5、添加了 Everyone 用户后，将文件夹的权限改为「读取/写入」，点击右下角的「共享」。</p><p><img src="https://pic1.zhimg.com/80/v2-eadec0f44566d1b5490613e2661df6a8_720w.jpg" alt="img"></p><p>6、查看自己的ipv4地址。用手机文件app连接到该ip，输入用户名和密码，即可共享此文件。<img src="https://pic1.zhimg.com/80/v2-3909bf6dd6e6fece8e77c2ede991eba0_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-707141eb32295cc607880e44095636f4_720w.jpg" alt="img"></p><p>注意：名称：29133密码：luohao123…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;遇到的bug：&lt;/p&gt;
&lt;h1&gt;内容不可用无法显示文件夹内容&lt;/h1&gt;
&lt;p&gt;出错原因是啥不知道&lt;/p&gt;
&lt;p&gt;解决办法：删除链接的服务器然后重新连接。&lt;/p&gt;
&lt;p&gt;共享文件夹方法：&lt;/p&gt;
&lt;h6 id=&quot;1、在-Windows-电脑新建一个文件夹，右击「属性」，选择「</summary>
      
    
    
    
    <category term="电脑使用" scheme="https://qzl.luoxiaohei.fun/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="windows使用技巧" scheme="https://qzl.luoxiaohei.fun/tags/windows%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://qzl.luoxiaohei.fun/posts/0.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/0.html</id>
    <published>2023-06-07T02:41:42.618Z</published>
    <updated>2023-06-09T03:56:30.111Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 力扣hot100–002<br>date: 2022-5-19 18：02：23<br>tags: c++、算法<br>categories: 算法题<br>cover: ‘<a href="https://s2.loli.net/2023/06/05/3Xb2OHjnB7wTkds.jpg">https://s2.loli.net/2023/06/05/3Xb2OHjnB7wTkds.jpg</a>’<br>abbrlink: 3f31bd15<br>​—</p><h1><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h1>题目描述</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><mark class="hl-label red">eg：</mark> <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><h1>解决思路</h1><p>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，比如 <code>987 + 23 = 987 + 023 = 1010</code></p><p>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个<mark class="hl-label blue">预先指针pre</mark> ，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</p><p><strong>过程如图所示：</strong></p><mark class="hl-label pink">1、初始化</mark> <img src="https://s2.loli.net/2022/05/19/xaudLjwIZAX1DOU.png" style="zoom:50%;" /><mark class="hl-label pink">2、过程</mark> <img src="https://s2.loli.net/2022/05/19/SOIz7tjnEhuqxXg.png" style="zoom:50%;" /><mark class="hl-label pink">3、结果</mark> <img src="https://s2.loli.net/2022/05/19/28JXya1KdxwNUec.png" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//初始化预先指针</span></span><br><span class="line">        ListNode* nex = pre; <span class="comment">//设置移动指针</span></span><br><span class="line">        <span class="type">int</span> tag = <span class="number">0</span>; <span class="comment">//进位标志位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            <span class="type">int</span> y = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            <span class="type">int</span> sum = x + y + tag;</span><br><span class="line">            tag = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            nex-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            nex = nex-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">nullptr</span>)</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>(tag == <span class="number">1</span>)&#123;  <span class="comment">// 考虑最后的进位1</span></span><br><span class="line">            nex-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(tag);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="c-结构体">c++结构体</h2><p>相关操作及注意事项：</p><h5 id="定义结构体">定义结构体</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">My</span>&#123;</span><br><span class="line">    My *left;</span><br><span class="line">    My *right;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">My</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">My</span>(<span class="type">int</span> val):<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>),<span class="built_in">val</span>(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="访问结构体元素">访问结构体元素</h5><p>结构体中的变量，可以直接通过<mark class="hl-label pink">点操作符</mark> 来访问。</p><p>而对于结构体指针而言：必须通过<mark class="hl-label pink">->符号</mark> 来访问指针所指结构体的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My m;</span><br><span class="line">    m.val = <span class="number">1</span>;</span><br><span class="line">    My *mm;</span><br><span class="line">    mm = &amp;m;</span><br><span class="line">    cout&lt;&lt;mm-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>声明一个结构体指针记得初始化，一定要初始化，不初始化会出事（重要的事情说三遍）下面代码就会报错，没有初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My *m;</span><br><span class="line">    m-&gt;val = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用new申请了内存空间。问题即可解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    My *m;</span><br><span class="line">    m = <span class="keyword">new</span> <span class="built_in">My</span>(<span class="number">3</span>);</span><br><span class="line">    m-&gt;val = <span class="number">4</span>;</span><br><span class="line">    cout&lt;&lt;m-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 力扣hot100–002&lt;br&gt;
date: 2022-5-19 18：02：23&lt;br&gt;
tags: c++、算法&lt;br&gt;
categories: 算法题&lt;br&gt;
cover: ‘&lt;a href=&quot;https://s2.loli.net/2023/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>力扣hot100--031 下一个排列</title>
    <link href="https://qzl.luoxiaohei.fun/posts/82686913.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/82686913.html</id>
    <published>2023-06-07T02:41:42.616Z</published>
    <updated>2023-06-07T03:00:16.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-下一个排列"><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><h2 id="题目描述">题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><h2 id="示例">示例</h2><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[1,3,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,1]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure><h2 id="思路">思路</h2><h2 id="1-调用STL的函数">#1 调用STL的函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// STL功能和题目描述一致</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-手动实现-时间复杂度O-n-空间复杂度O-1">#2 手动实现 时间复杂度O(n),空间复杂度O(1)</h2><ul><li>从后往前找到第一个【相邻升序对】，即A[i]&lt;A[i+1]。此时A[i+1,end)为降序。</li><li>在区间[i+1,end)中，从后往前找到第一个大于A[i]的元素A[j]</li><li>交换A[i]和A[j]，此时A[i+1,end)一定还是降序，因为A[j]是从右侧起第一个大于A[i]的值</li><li>反转A[i+1,end)，变成升序</li></ul><p>应用场景：可兼容处理含有重复元素的全排列问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; -- i) &#123; <span class="comment">// 从后往前找到第一个相邻升序对</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 无相邻升序对，必定为非递减序列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= i+<span class="number">1</span>; -- j) &#123; <span class="comment">// 从后往前[i+1,end)找第一个大于a[i+1]的值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i],nums[j]); <span class="comment">// 交换二者</span></span><br><span class="line">                    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>()); <span class="comment">// 反转[i+1,end)，变成升序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;31-下一个排列&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/next-permutation/&quot;&gt;31. 下一个排列&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;整数数组的一个 排列  就是将其所有成</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--004</title>
    <link href="https://qzl.luoxiaohei.fun/posts/64d68daa.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/64d68daa.html</id>
    <published>2023-06-07T02:41:42.615Z</published>
    <updated>2023-06-07T03:00:16.573Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>📖每日更新一道力扣hot100</p></div><div class="note success flat"><p>📚更新于5.18</p></div><hr><h1>4.寻找两个有序数组的中位数</h1><h2 id="题目描述">题目描述</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><h2 id="实例">实例</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><h2 id="解题思路">解题思路</h2><p>我只能想到归并排序了，答案中的二分查找理解不了，所以总结一下归并排序吧。</p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1[<span class="number">2</span>]=&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> num2[<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">    num1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    num1[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    num2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num3[<span class="number">3</span>]=&#123;&#125;;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j!=<span class="number">1</span>)&#123;</span><br><span class="line">            num3[count++]=num2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=<span class="number">2</span>)&#123;</span><br><span class="line">                num3[count++] = num1[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1[i]&lt;num2[j])&#123;</span><br><span class="line">            num3[count++] = num1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            num3[count++] = num2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断中位数</span></span><br><span class="line">    <span class="keyword">if</span>(count%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;num3[(count/<span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;num3[count/<span class="number">2</span>]+num3[(count/<span class="number">2</span>)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>很多排序算法，比如快排，归并排序，二分查找算法，这些稍微复杂一点的算法都不能手撕代码。很是头疼。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;📖每日更新一道力扣hot100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note success flat&quot;&gt;&lt;p&gt;📚更新于5.18&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h1&gt;4.寻找两个有序数组的中位数&lt;/h</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--017--电话号码的字母组合</title>
    <link href="https://qzl.luoxiaohei.fun/posts/b33db4a9.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/b33db4a9.html</id>
    <published>2023-06-07T02:41:42.614Z</published>
    <updated>2023-06-07T03:00:16.574Z</updated>
    
    <content type="html"><![CDATA[<h1>电话号码的字母组合</h1><h2 id="题目描述：">题目描述：</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209270900591.png" alt="img"></p><h2 id="实例：">实例：</h2><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;af&quot;</span>,<span class="string">&quot;bd&quot;</span>,<span class="string">&quot;be&quot;</span>,<span class="string">&quot;bf&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ce&quot;</span>,<span class="string">&quot;cf&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary> 哔哔 </summary>              <div class='content'>              <p>开始做这道题脑子里面想到的就是<p class='p red'>DFS</p>（深度优先遍历）奈何<p class='p red'>DFS</p>我只在树中学过，在这种一一映射的遍历中还是第一次见。题解说：<p class='p red'>回溯算法</p>用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><p>可惜了，我回溯代码也不会写。回溯算法的文字描述如下（我还是看的一知半解）</p><hr><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><hr><p>代码是我一边借鉴一边动脑写出来的，但是下次遇到相同的题目，我还是不会写吧！哎</p>              </div>            </details><h2 id="解题代码：">解题代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res; </span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; a = &#123;</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;def&quot;</span>&#125;,&#123;<span class="number">4</span>,<span class="string">&quot;ghi&quot;</span>&#125;,&#123;<span class="number">5</span>,<span class="string">&quot;jkl&quot;</span>&#125;,&#123;<span class="number">6</span>,<span class="string">&quot;mno&quot;</span>&#125;,&#123;<span class="number">7</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="number">8</span>,<span class="string">&quot;tuv&quot;</span>&#125;,&#123;<span class="number">9</span>,<span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    string temp;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> depth,string digits)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth == digits.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> sum = digits[depth] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a[sum].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(a[sum][i]);</span><br><span class="line">                <span class="built_in">DFS</span>(depth+<span class="number">1</span>,digits);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">lettercombinations</span><span class="params">(string digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>,digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    string b =  <span class="string">&quot;23&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; s;</span><br><span class="line">    s = a.<span class="built_in">lettercombinations</span>(b);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::iterator  itr = s.<span class="built_in">begin</span>(); itr != s.<span class="built_in">end</span>(); itr++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*itr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>回溯方法大有用处，应该好好吸收！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;电话号码的字母组合&lt;/h1&gt;
&lt;h2 id=&quot;题目描述：&quot;&gt;题目描述：&lt;/h2&gt;
&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自然数与有理数的双射函数</title>
    <link href="https://qzl.luoxiaohei.fun/posts/5d401e2a.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/5d401e2a.html</id>
    <published>2023-06-07T02:41:42.613Z</published>
    <updated>2023-06-07T03:00:16.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法题：自然数与有理数的双射函数">算法题：自然数与有理数的双射函数</h2><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231123258.png" alt="21d9a97ee2e018e313bc7947b0740658.png"></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231124462.png" alt="e2b706093c148938a0762b0d415a8116.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入：多行，每行两个整数<span class="selector-tag">a</span>和<span class="selector-tag">b</span>，中间有一个空格，表示一个有理数<span class="selector-tag">a</span>/<span class="selector-tag">b</span></span><br><span class="line"></span><br><span class="line">输出：对应的多行，每行一个整数，有理数<span class="selector-tag">a</span>/<span class="selector-tag">b</span>的双射函数对应的自然数，结果&lt;<span class="number">500000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line"></span><br><span class="line">-<span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-<span class="number">4</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">-<span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出样例：</span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>思路：最开始的想法就是找规律了，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">2</span> -<span class="number">1</span>/<span class="number">2</span> -<span class="number">1</span> -<span class="number">2</span> -<span class="number">2</span>/<span class="number">3</span> -<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span>/<span class="number">2</span> <span class="number">3</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> -<span class="number">1</span>/<span class="number">4</span> -<span class="number">3</span>/<span class="number">4</span> -<span class="number">3</span>/<span class="number">2</span> -<span class="number">3</span> -<span class="number">4</span> -<span class="number">4</span>/<span class="number">3</span> -<span class="number">4</span>/<span class="number">5</span> -<span class="number">3</span>/<span class="number">5</span> -<span class="number">2</span>/<span class="number">5</span> -<span class="number">1</span>/<span class="number">5</span> <span class="number">1</span>/<span class="number">5</span> <span class="number">2</span>/<span class="number">5</span> <span class="number">3</span>/<span class="number">5</span> <span class="number">4</span>/<span class="number">5</span> <span class="number">4</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><p>发现规律并不明显，很难模拟它的拟合方程（就是没有公式，没有规律）。</p><p>没有数字规律那就从图像中找规律，我发现图像是一个个凹字的嵌套，如图：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209231128750.png" alt="image-20220923112831656"></p><p>我们只需要模拟出凹字的笔画就好啦（最小的凹字长宽分别为2：1。画完一个凹字之后接下来的凹字由图像可知长宽分别加4：2）</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">double</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>,y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    p[x/y] = count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        map&lt;<span class="type">double</span>,<span class="type">int</span>&gt;::iterator it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">        <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;a;j++)&#123;</span><br><span class="line">            y++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; b; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            x--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; a; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            y--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        x--;</span><br><span class="line">        it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">        <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            y++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b+<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            x++;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            y--;</span><br><span class="line">            it = p.<span class="built_in">find</span>(x/y);</span><br><span class="line">            <span class="keyword">if</span>(it==p.<span class="built_in">end</span>())</span><br><span class="line">            p[x/y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        a+=<span class="number">2</span>;</span><br><span class="line">        b+=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> Q1,Q2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     for(auto it : p)&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; it.first &lt;&lt;&quot; &quot;&lt;&lt; it.second &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;Q1&gt;&gt;Q2)</span><br><span class="line">        cout&lt;&lt;p[Q1/Q2]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：N 空间复杂度：N</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法题：自然数与有理数的双射函数&quot;&gt;算法题：自然数与有理数的双射函数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jack8luo/picture/main/202209231123258.png&quot; al</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--015</title>
    <link href="https://qzl.luoxiaohei.fun/posts/aca8c7d.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/aca8c7d.html</id>
    <published>2023-06-07T02:41:42.611Z</published>
    <updated>2023-06-07T03:00:16.571Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>📖每日更新一道力扣hot100</p></div><div class="note success flat"><p>📚更新于5.18</p></div><hr><h2 id="题目描述：">题目描述：</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><h2 id="实例：">实例：</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,0,1,2,<span class="string">-1</span>,<span class="string">-4</span>]</span><br><span class="line">输出：[[<span class="string">-1</span>,<span class="string">-1</span>,2],[<span class="string">-1</span>,0,1]]</span><br></pre></td></tr></table></figure><h2 id="解题思路：">解题思路：</h2><p>转换为二数之和问题，为了排除重复元素，开始想到的是用hash来去重，但是三元组的map不知道能不能去重复。我来试一下：实验表明，map只有key不能重复，value是可以重复的。</p><p>1、排序2、转化为二数之和问题3、注意重复问题</p><h2 id="实现代码：">实现代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">     <span class="type">int</span> n  = nums.<span class="built_in">size</span>();</span><br><span class="line">     <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; first++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 不能有重复出现的三元组，if语句完美规避了0处越界和first重复问题★</span></span><br><span class="line">        <span class="keyword">if</span>(first &gt; <span class="number">0</span>&amp;&amp;nums[first] == nums[first - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> third = n <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> target = -nums[first];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> second = first +<span class="number">1</span> ; second &lt; n; second++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不能有重复出现的三元组，if语句完美从first下一个元素开始和second重复问题★</span></span><br><span class="line">            <span class="keyword">if</span>(second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[second]+nums[third] &gt; target)&#123;</span><br><span class="line">            --third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(second == third)</span><br><span class="line">           &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[second] + nums[third]  == target)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;nums[first],nums[second],nums[third]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>&#125;;</span><br><span class="line">    Solution n;</span><br><span class="line">    <span class="keyword">auto</span> b = n.<span class="built_in">threeSum</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b[i][<span class="number">0</span>]&lt;&lt;b[i][<span class="number">1</span>]&lt;&lt;b[i][<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;b.size();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>多看看STL吧。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;📖每日更新一道力扣hot100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note success flat&quot;&gt;&lt;p&gt;📚更新于5.18&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h2 id=&quot;题目描述：&quot;&gt;题目描述：&lt;</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--011</title>
    <link href="https://qzl.luoxiaohei.fun/posts/da74864.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/da74864.html</id>
    <published>2023-06-07T02:41:42.608Z</published>
    <updated>2023-06-07T03:00:16.571Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>📖每日更新一道力扣hot100</p></div><div class="note success flat"><p>📚更新于5.18</p></div><h4 id="11-盛最多水的容器"><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209091318849.jpeg" alt="img"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例 2：</p><p>输入：height = [1,1]<br>输出：1</p><h2 id="题解">题解</h2><p>1、暴力法</p><p>两个for循环遍历所有可能的解，比较最大值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; height.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = j-i;</span><br><span class="line">                <span class="keyword">if</span>(len*<span class="built_in">min</span>(height[i],height[j])&gt;maxArea)</span><br><span class="line">                    maxArea = len*<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    Solution b;</span><br><span class="line">    cout&lt;&lt;b.<span class="built_in">MaxArea</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、双指针法</p><p>两个边界的问题，用双指针法最为合适，每次舍去两边界中最小的边，因为容量=最小边界*宽度。如果这个容量不是最大值，那么移动最大边界不可能再有最大值出现了，所以只能移动最小边界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((end - begin) * <span class="built_in">min</span>(height[begin], height[end]) &gt; maxArea)</span><br><span class="line">                maxArea = (end - begin) * <span class="built_in">min</span>(height[begin], height[end]);</span><br><span class="line">            <span class="keyword">if</span> (height[begin] &gt; height[end])</span><br><span class="line">                end--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                begin++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    Solution b;</span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">MaxArea</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：vector真好用，比传统数组好用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;📖每日更新一道力扣hot100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note success flat&quot;&gt;&lt;p&gt;📚更新于5.18&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;11-盛最多水的容器&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--005</title>
    <link href="https://qzl.luoxiaohei.fun/posts/13d1bd3c.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/13d1bd3c.html</id>
    <published>2023-06-07T02:41:42.605Z</published>
    <updated>2023-06-07T03:00:16.569Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>📖每日更新一道力扣hot100</p></div><div class="note success flat"><p>📚更新于5.18</p></div><h1>5、最长回文子串</h1><h2 id="题目描述">题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><h2 id="实例">实例</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><h2 id="思路">思路</h2><p>有两种方法，一种是中心扩展法，比较好理解，遍历、若左边的或者右边的元素和当前元素相等则回文长度+1，若左边的和右边的相等，则回文长度+2.</p><p>第二种是动态规划，我们用 P(i,j)<em>P</em>(<em>i</em>,<em>j</em>) 表示字符串 s<em>s</em> 的第 <em>i</em> 到 <em>j</em> 个字母组成的串是否为回文串。状态转移方程：<em>P</em>(<em>i</em>,<em>j</em>)=<em>P</em>(<em>i</em>+1,<em>j</em>−1)∧(S[i]==S[j])。边界条件：<img src="https://raw.githubusercontent.com/jack8luo/picture/main/202209061451886.png" alt="image-20220906145111850"></p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; s.<span class="built_in">size</span>(); mid++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; s[left] == s[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt;= s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; s[right] == s[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt;= s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; s[left] == s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                len += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; maxLen)&#123;</span><br><span class="line">                maxLeft = left;</span><br><span class="line">                maxRight = right;</span><br><span class="line">                maxLen = len;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxLeft + <span class="number">1</span>,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中心扩展法</span></span><br><span class="line">    string S = <span class="string">&quot;abcdcba&quot;</span>;</span><br><span class="line">    Solution a;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">longestPalindrome</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">if</span> (n&lt;<span class="number">2</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; L++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = L + i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; j - i &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    Solution a;</span><br><span class="line">    string s = <span class="string">&quot;dd&quot;</span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">longestPalindrome</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>vector用法不是很熟练，动态规划的边界条件和状态转移方程使用不熟练。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;📖每日更新一道力扣hot100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note success flat&quot;&gt;&lt;p&gt;📚更新于5.18&lt;/p&gt;
&lt;/div&gt;
&lt;h1&gt;5、最长回文子串&lt;/h1&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--0019 删除链表倒数第N位</title>
    <link href="https://qzl.luoxiaohei.fun/posts/2977d1eb.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/2977d1eb.html</id>
    <published>2023-06-07T02:41:42.604Z</published>
    <updated>2023-06-07T03:00:16.575Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091306235.jpeg" alt="img"></p><h2 id="示例">示例</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary> 哔哔 </summary>              <div class='content'>              <p>这是道简单的链表题，对我们熟悉链表操作有很好的帮助。</p><p>链表最重要的操作就是创增删改查。我们熟悉这些操作就行了。还有另外的双链表，循环链表大同小异，可以放在以后再看。</p><hr><p>思路就是先获取链表的长度，然后由倒数第几个转化为第几个的问题。</p>              </div>            </details><p>实现代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span>&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="constructor">ListNode()</span> : <span class="keyword">val</span>(<span class="number">0</span>), next(nullptr) &#123;&#125;</span><br><span class="line">    <span class="constructor">ListNode(<span class="params">int</span> <span class="params">x</span>)</span> : <span class="keyword">val</span>(x), next(nullptr) &#123;&#125;</span><br><span class="line">    <span class="constructor">ListNode(<span class="params">int</span> <span class="params">x</span>, ListNode <span class="operator">*</span><span class="params">next</span>)</span> : <span class="keyword">val</span>(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* remove<span class="constructor">NthFromEnd(ListNode<span class="operator">*</span> <span class="params">head</span>, <span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">         ListNode* p = head;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        n = i-n;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">if</span>(n<span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            n-=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span>&#123;</span><br><span class="line">    ListNode* hea = <span class="keyword">new</span> <span class="constructor">ListNode(1)</span>;</span><br><span class="line">    ListNode* he = hea;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        he-&gt;next = <span class="keyword">new</span> <span class="constructor">ListNode(<span class="params">i</span>)</span>;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution a;</span><br><span class="line">    ListNode* b = a.remove<span class="constructor">NthFromEnd(<span class="params">hea</span>,1)</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b-&gt;<span class="keyword">val</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        b=b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>**进阶：**你能尝试使用一趟扫描实现吗？</h1><p>扫描一遍就得出答案可以使用双指针，思路如下：</p><p>设置两个头指针p、q，移动q使得两指针相距n位，然后同时移动两个指针，当q到尾部时，p指的自然是倒数n位。</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091320311.gif" alt="img"></p><p>实现代码</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">     ListNode* dummyHead = new ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="title">dummyHead</span>-&gt;</span>next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* p = dummyHead;</span><br><span class="line">        ListNode* q = dummyHead;</span><br><span class="line">        <span class="keyword">for</span>( int i = <span class="number">0</span> ; i &lt; n + <span class="number">1</span> ; i ++ )&#123;</span><br><span class="line">            <span class="function"><span class="title">q</span> = q-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q)&#123;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">q</span> = q-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        L<span class="function"><span class="title">istNode</span>* delNode = p-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span> = delNode-&gt;</span>next;</span><br><span class="line">        delete delNode;</span><br><span class="line"></span><br><span class="line">        L<span class="function"><span class="title">istNode</span>* retNode = dummyHead-&gt;</span>next;</span><br><span class="line">        delete dummyHead;</span><br><span class="line"></span><br><span class="line">        return retNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end-of-list/&quot;&gt;19. 删除链表的倒数第 N 个结点&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给你一个链表，删除链表的倒数第 &lt;code&gt;n&lt;/code&gt; 个</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--022 括号生成</title>
    <link href="https://qzl.luoxiaohei.fun/posts/3f31bd15.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/3f31bd15.html</id>
    <published>2023-06-07T02:41:42.602Z</published>
    <updated>2023-06-07T03:00:16.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary> 哔哔 </summary>              <div class='content'>              <p>这道题目思路有很多，但是我一个都没想到… 看了天才们的解法，有以下两个：递归和动态规划。</p><p>好像递归转为非递归用的就是动态规划…</p><p>这两种解法真的好难掌握一看就懂一写就废…</p>              </div>            </details><h2 id="递归实现">递归实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">res</span>(n + <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">0</span>] = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        res[<span class="number">1</span>] = &#123;<span class="string">&quot;()&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (string p : res[j])</span><br><span class="line">                    <span class="keyword">for</span> (string q : res[i - j - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        string str = <span class="string">&quot;(&quot;</span> + p + <span class="string">&quot;)&quot;</span> + q;</span><br><span class="line">                        res[i].<span class="built_in">push_back</span>(str);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    <span class="comment">// list&lt;string&gt; b;</span></span><br><span class="line">    vector&lt;string&gt; b;</span><br><span class="line">    b = a.<span class="built_in">generateParenthesis</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// for (string c : b)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划实现">动态规划实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    list&lt;string&gt; res;</span><br><span class="line">    <span class="function">list&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string str, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号=右括号时，只能加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="built_in">dfs</span>(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 左括号大于右括号时，当左括号取完前，取左括号，取完后取右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(str + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">            <span class="built_in">dfs</span>(str + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution a;</span><br><span class="line">    list&lt;string&gt; b;</span><br><span class="line">    <span class="comment">// vector&lt;string&gt; b;</span></span><br><span class="line">    b = a.<span class="built_in">generateParenthesis</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// for (auto it = b.begin(); it != b.end(); it++)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (string c : b)</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> green，递归哔哔 </summary>              <div class='content'>              <p>每种解法都有特定的思路。</p><p>递归来讲：剩余左括号总数要小于等于右括号。定义函数dfs(str,left,right)。str是生成的字符串，left表示剩下的“（”，right表示剩下的“）”。</p><p>1、定义递归出口：当左括号和右括号都填完了，return即可。</p><p>2、递归顺序：考虑左括号和右括号的性质，当左右括号数相同，先递归左括号（保证左括号数&lt;=n)，再递归右括号。</p>              </div>            </details><details class="folding-tag" green><summary> 动态规划哔哔 </summary>              <div class='content'>              <p>思路：求结果n时，我们可以从结果n-1中插入一个括号求解。（x）会有重复解的情况。</p><p>求结果n时，考虑 <code>i=n</code> 时相比 <code>n-1</code> 组括号增加的那一组括号的位置。括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p><p>规划方程：</p><p>“(” + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】</p>              </div>            </details><p>tip:</p><p><strong>我想把三个常用的序列式放在一起对比一下是有必要的：</strong></p><p><strong>vector ：</strong> vector和built-in数组类似，拥有一段连续的内存空间，能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当插入较多的元素后，预留内存空间可能不够，需要重新申请一块足够大的内存并把原来的数据拷贝到新的内存空间。这些影响了vector的效率，但是实际上用的最多的还是vector容器，建议大多数时候使用vector效率一般是不错的。vector的用法解析可以参考本人的另一篇随笔：<a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/08/2627666.html">http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/08/2627666.html</a></p><p><strong>list：</strong>   list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p><p><strong>deque：</strong> deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上与list的效率也差不多。</p><p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，具体可以遵循下面的****原则****：</p><ul><li><p>如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p></li><li><p>如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p></li><li><p>如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p></li></ul><p>遍历:</p><p>对于三种容器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="keyword">for</span> (string c : b)</span><br><span class="line">       cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--021 合并子串</title>
    <link href="https://qzl.luoxiaohei.fun/posts/aa423386.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/aa423386.html</id>
    <published>2023-06-07T02:41:42.600Z</published>
    <updated>2023-06-07T03:00:16.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210131816011.jpeg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[1,2,4]</span>, l2 = <span class="comment">[1,3,4]</span></span><br><span class="line">输出：<span class="comment">[1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure><h2 id="解题思路">解题思路</h2><details class="folding-tag" green><summary> 哔哔 </summary>              <div class='content'>              <p>之前写过这道题目用的是迭代的思路，所以实现起来还是很熟练的。但是我在解题中看到了递归的解法，最递归害怕者的我有很好的帮助。</p>              </div>            </details><h2 id="迭代代码实现">迭代代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x,ListNode *next):<span class="built_in">val</span>(x),<span class="built_in">next</span>(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode  result = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* r = result;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">nullptr</span> &amp;&amp; list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&gt;list2-&gt;val)&#123;</span><br><span class="line">                result-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            result = result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span>)</span><br><span class="line">            result-&gt;next = list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">nullptr</span>)</span><br><span class="line">            result-&gt;next = list1;</span><br><span class="line">        <span class="keyword">return</span> r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ListNode* a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归代码实现">递归代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;将两个升序链表合并为一个新的 &lt;strong&gt;升序&lt;/strong&gt; 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--020 符号匹配</title>
    <link href="https://qzl.luoxiaohei.fun/posts/b88ae749.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/b88ae749.html</id>
    <published>2023-06-07T02:41:42.599Z</published>
    <updated>2023-06-07T03:00:16.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述：">题目描述：</h2><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="解题思路">解题思路</h2><details class="folding-tag" green><summary> 哔哔 </summary>              <div class='content'>              <p>这就是编译原理学的符号匹配，话说编译原理也忘得差不多了，里面正则表达式的计算之类的东西，忘了以后再捡起来吧，对了感谢肖建老师教授的编译原理，个人感觉非常的好。（有一次把肖建老师叫成了肖战，哈哈哈。。。）</p>              </div>            </details><p>算法执行过程：</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210131055496.gif" alt="20.gif"></p><h2 id="解题代码：">解题代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVaild</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                a.<span class="built_in">pop</span>();<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution tex;</span><br><span class="line">    string str = <span class="string">&quot;(&#123;[)&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(tex.<span class="built_in">isVaild</span>(str))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>这道题目比较简单，就是一个符号匹配，利用栈即可解决问题，但是我又看了一位大佬的代码，里面用map映射了符号与数字之间的关系，再用简单的一行命令判断即可求解，很巧妙，代码贴下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m&#123;&#123;<span class="string">&#x27;(&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;[&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;&#123;&#x27;</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&#x27;)&#x27;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&#x27;]&#x27;</span>,<span class="number">5</span>&#125;,&#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">bool</span> istrue=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="type">int</span> flag=m[c];</span><br><span class="line">            <span class="keyword">if</span>(flag&gt;=<span class="number">1</span>&amp;&amp;flag&lt;=<span class="number">3</span>) st.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()&amp;&amp;m[st.<span class="built_in">top</span>()]==flag<span class="number">-3</span>) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> &#123;istrue=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) istrue=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> istrue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;题目描述：&lt;/h2&gt;
&lt;p&gt;给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;p&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;
左括号必须以正确的顺序闭合。</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--001</title>
    <link href="https://qzl.luoxiaohei.fun/posts/14bc7925.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/14bc7925.html</id>
    <published>2023-06-07T02:41:42.598Z</published>
    <updated>2023-06-09T03:52:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>题目表述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出<mark class="hl-label pink">和</mark> 为目标值 target  的那两个整数，并返回它们的数组下标。</p><p>1、你可以假设每种输入只会对应<mark class="hl-label pink">一个答案</mark> 。但是，数组中同一个元素在答案里不能重复出现。</p><p>2、你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,7,11,15]</span>, target = 9</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br><span class="line">解释：两数相加=9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,4]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3]</span>, target = 6</span><br><span class="line">输出：<span class="comment">[0,1]</span></span><br></pre></td></tr></table></figure><h1>解题思路</h1><p>题目要求时间复杂度在<mark class="hl-label red">O(n2)</mark> 以下，所以暴力法是不可行的。</p><p>哈希表中查找的时间复杂度是<mark class="hl-label red">O（1）</mark> 。可以用哈希表对数组进行存储。例如：</p><p><img src="https://s2.loli.net/2022/05/18/Bh48vJZVN3lYXmy.png" alt=""></p><p><img src="https://s2.loli.net/2022/05/18/SlHEw2LkaxXW5BI.png" alt=""></p><h2 id="代码实现：">代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            a.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(nums[i],i));  <span class="comment">//初始化哈希表a</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">count</span>(target-nums[i]) &gt; <span class="number">0</span> &amp;&amp; (a[target-nums[i]] != i)) <span class="comment">//a.count(target-nums[i]) &gt; 0:判断哈希表中是否有两个相加等于target的数；a[target-nums[i]] != i：排除两个相同的数相加=target//a.count(i)查找到返回1，否则返回0；以为数组不含相同整数</span></span><br><span class="line">            &#123;</span><br><span class="line">                b[<span class="number">0</span>] = i;</span><br><span class="line">                b[<span class="number">1</span>] = a[target-nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="补充一些与哈希表有关的操作：">补充一些与哈希表有关的操作：</h2><h3 id="初始化和迭代：">初始化和迭代：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Mymap::const_iterator it = c1.<span class="built_in">begin</span>(); it != c1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">output:</span><br><span class="line">[a,<span class="number">1</span>],[b,<span class="number">2</span>],[c,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="函数clear：">函数clear：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">c1.<span class="built_in">clear</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size == &quot;</span> &lt;&lt; c1.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;empty() == &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; c1.<span class="built_in">empty</span>() &lt;&lt; std::endl; output:</span><br><span class="line">size == <span class="number">0</span> empty（）== <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="函数count（查找与指定元素匹配的数目）：">函数count（查找与指定元素匹配的数目）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mymap c1;</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">c1.<span class="built_in">insert</span>(Mymap::<span class="built_in">value_type</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;count(&#x27;A&#x27;) == &quot;</span> &lt;&lt; c1.<span class="built_in">count</span>(<span class="string">&#x27;A&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;count(&#x27;b&#x27;) == &quot;</span> &lt;&lt; c1.<span class="built_in">count</span>(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; std::endl; output:</span><br><span class="line">count（<span class="string">&#x27;A&#x27;</span>）== <span class="number">0</span> count（<span class="string">&#x27;b&#x27;</span>）== <span class="number">1</span></span><br></pre></td></tr></table></figure><p>函数find（查找指定元素）返回false和true。</p><p>还有各种各样的函数功能，记不了那么多了。</p><h2 id="归纳总结">归纳总结</h2><p>其实哈希表在数据结构中已经学过了，哈希函数是从关键字集合到地址集合的<mark class="hl-label pink">映像</mark>  。哈希函数其实是一个压缩映像，那么这种情况就不可避免的产生冲突，那么在建造哈希表时不仅要设定一个好的哈希函数，还要设定一种处理冲突的方法。</p><p>这道题就没有处理冲突的方法，因为它设置了一个和数组个数一样大的地址空间。这道题就是用到了哈希表查找的复杂度为1，并没有用到压缩存储的思想，更没有用到处理冲突的方法。常见的<mark class="hl-label pink">哈希函数</mark> 在数据结构中已经学习过了：直接定址法、除留余数法。常见的<mark class="hl-label pink">处理冲突方法</mark>  :开放定址法。具体先不管，挺容易懂得，代码实现就不一定了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;1. 两数之和&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;题目表述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出&lt;mark class=&quot;hl-label pi</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu22.04 中Drag and drop is not supported问题</title>
    <link href="https://qzl.luoxiaohei.fun/posts/2547a556.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/2547a556.html</id>
    <published>2023-06-07T02:41:42.452Z</published>
    <updated>2023-06-07T03:01:04.960Z</updated>
    
    <content type="html"><![CDATA[<h1>Ubuntu22.04 中Drag and drop is not supported问题</h1><p>解决方法<br>先在terminal中安装这两个程序</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install </span>gnome-<span class="keyword">shell-extension-prefs</span></span><br><span class="line"><span class="keyword"></span>sudo apt <span class="keyword">install </span>nemo</span><br></pre></td></tr></table></figure><p>左下角的application中选择extension， 将Desktop icons NG 选项关闭</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/image-20230330202439439.png" alt="image-20230330202439439"></p><p>左下角的application中选择startup application preference， 添加如下命令</p><p><img src="https://img-blog.csdnimg.cn/1df319278b124816a90579738f0c6995.png" alt="img"></p><p>将程序重启后即可在host和vm间进行拖动传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Ubuntu22.04 中Drag and drop is not supported问题&lt;/h1&gt;
&lt;p&gt;解决方法&lt;br&gt;
先在terminal中安装这两个程序&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="Ubuntu22.04" scheme="https://qzl.luoxiaohei.fun/tags/Ubuntu22-04/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署到gitee出现js和css文件丢失</title>
    <link href="https://qzl.luoxiaohei.fun/posts/3300d37c.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/3300d37c.html</id>
    <published>2023-06-07T02:41:42.273Z</published>
    <updated>2023-06-07T03:00:45.936Z</updated>
    
    <content type="html"><![CDATA[<h1>hexo部署到gitee出现js和css文件丢失</h1><p>前言：</p><p>因为国内能访问的代码部署平台只有gitee了，然而gitee审核太严格了，有时候好看的（涩）图片会被挂掉，都有点不敢用了。但是为了让不能上外网的小伙伴们看到我的blog，我还是研究了一下gitee，并成功部署了（庆祝）。虽然过程很头大，其中url和deploy的配置很烦，经常出错。所以总结一下同时部署gitee和github，实现大家同时访问。（对了， gitee现在不支持自定义域名，哎，无语。你们只能记住又长又臭的网址了：<a href="https://icebress.gitee.io/jack8luo/">骆小黑的一亩三分地 - 阿妮亚 (gitee.io)</a></p><details class="folding-tag" cyan><summary> github绑定了我喜欢的域名，部署配置如下 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">#url: https://blog.luoxiaohei.co</span><br><span class="line">#root: /</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">#  repo: git@gitee.com:icebress/jack8luo.git</span><br><span class="line">#  branch: master</span><br><span class="line">    github: git@github.com:jack8luo/jack8luo.github.io.git,master</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" cyan><summary> gitee个人版不能绑定自定义域名，配置如下 </summary>              <div class='content'>              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Gitee URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: https://icebress.gitee.io/jack8luo</span><br><span class="line">root: /jack8luo</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@gitee.com:icebress/jack8luo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>              </div>            </details><p>掰掰! <svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;hexo部署到gitee出现js和css文件丢失&lt;/h1&gt;
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;因为国内能访问的代码部署平台只有gitee了，然而gitee审核太严格了，有时候好看的（涩）图片会被挂掉，都有点不敢用了。但是为了让不能上外网的小伙伴们看到我的blog，我还是研究了一</summary>
      
    
    
    
    <category term="hexo" scheme="https://qzl.luoxiaohei.fun/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://qzl.luoxiaohei.fun/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>最优化</title>
    <link href="https://qzl.luoxiaohei.fun/posts/5e792134.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/5e792134.html</id>
    <published>2023-06-07T02:41:42.262Z</published>
    <updated>2023-06-07T03:00:16.566Z</updated>
    
    <content type="html"><![CDATA[<h1>最优化理论</h1><p>1.极点<br>极点的定义及理解<br>Definition 2.6 Let P be a polyhedron. A vector x ∈ P is an extreme point of P if we cannot find two vectors y, z ∈ P, both different from x, and a scalar λ ∈ (0,1), such that x = λy + (1 - λ)z.</p><p>定义中给出了一种严格证明极点 (extreme point) 的方法，即：极点无法被另外两个点的线性组合表示出。若我们想用概括性的图像思维来描述极点的话，请先看下图（所有的极点都已用字母标出）</p><p><img src="https://raw.githubusercontent.com/jack8luo/picture/main/202210091540298.jpeg" alt="在这里插入图片描述">通过观察不难发现，所有的极点都是凸集的“角(corner)”，即：你无法找到相异的两点，使得这些“角”在这两点的连线上。这就是我对于极点的直观几何理解。<br>当然，这是在二维平面上的，这里希望读者自己去思考在3,4,…,n维情况下，极点究竟如何定义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;最优化理论&lt;/h1&gt;
&lt;p&gt;1.极点&lt;br&gt;
极点的定义及理解&lt;br&gt;
Definition 2.6 Let P be a polyhedron. A vector x ∈ P is an extreme point of P if we cannot find two </summary>
      
    
    
    
    <category term="最优化" scheme="https://qzl.luoxiaohei.fun/categories/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="最优化" scheme="https://qzl.luoxiaohei.fun/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>优雅搞定word论文模板&amp;图片&amp;表格</title>
    <link href="https://qzl.luoxiaohei.fun/posts/c6226ada.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/c6226ada.html</id>
    <published>2023-06-07T02:41:42.238Z</published>
    <updated>2023-06-08T04:40:05.552Z</updated>
    
    <content type="html"><![CDATA[<h1>优雅搞定word论文模板</h1><h3 id="Q：怎么修改默认标题字体">Q：怎么修改默认标题字体</h3><h3 id="A：右键点击修改。">A：右键点击修改。</h3><p><img src="https://s2.loli.net/2022/05/24/6TN9RorpljU15uM.png" alt="image-20220524213950373"></p><h3 id="点击修改字体">点击修改字体</h3><p><img src="https://s2.loli.net/2022/05/24/fmxbRcoUyikV21D.png" alt="image-20220524214048455"></p><h3 id="修改成一级标题三号中文宋体黑体居中，英文字体times-new-roman。">修改成一级标题三号中文宋体黑体居中，英文字体times new roman。</h3><p><img src="https://s2.loli.net/2022/05/24/VxncEFvARZ7tzPq.png" alt="image-20220524214244871"></p><p>设置行距在段落中有，设置两倍行距。</p><p>同样地设置正文字体：宋体小四times new roman，行间距1.25。二级三级标题设置方法一样。</p><h2 id="标号如何自动生成：">标号如何自动生成：</h2><h3 id="Q-如何设置自己想要的标号，比如：第一章、第1章这种。">Q:如何设置自己想要的标号，比如：第一章、第1章这种。</h3><h3 id="A-点击开始选项栏中的定义新的多级列表">A:点击开始选项栏中的定义新的多级列表</h3><p><img src="https://s2.loli.net/2022/05/24/CDUyq4IovX3NfSz.png" alt="image-20220524214850349"></p><p><img src="https://s2.loli.net/2022/05/24/Vsvq47aibjGlrfD.png" alt="image-20220524215407245"></p><h3 id="Q-如何设置成第一章1-1、1-2这样子">Q:如何设置成第一章1.1、1.2这样子</h3><h3 id="A-image-20220524215617233">A:<img src="https://s2.loli.net/2022/05/24/gbUqj3WoXRlsHVQ.png" alt="image-20220524215617233"></h3><p><img src="https://s2.loli.net/2022/05/24/MyIELQmtcxAnjdT.png" alt="image-20220524220420629"></p><h1>优雅搞定word论文图片&amp;表格</h1><p>图片样式选择嵌入型</p><p><img src="https://s2.loli.net/2022/05/24/2OdfhGF3YaocMrA.png" alt="image-20220524220740210"></p><p><img src="https://s2.loli.net/2022/05/24/1pOgrnemJPUki7z.png" alt="image-20220524220840289"></p><p>点击引用选项中的交叉引用，可以插入引用，但是会遇见如下情况：</p><p><img src="https://s2.loli.net/2022/05/24/TSg1xhmIKn3Ajqd.png" alt="image-20220524221112075"></p><p>解决办法：ctrl + A全选，按F9刷新即可解决。</p><p>tips：两张图片并排放可以用表格实现，插入两列表格，然后插入图片，最后在表格设计中隐藏框框。</p><p>tips：两张图片组合成一张图片：1、设置图片为四周型。2、选中两张图片，点击组合。最后设置为嵌入型就可以。</p><p>Q:如果我们标题是汉字一，图片编号会变成一-1这样子，怎么办？</p><p>A:按Alt+F9，在每章标题上按ctrl+F9进入域，输入SEQ seq \h</p><p><img src="https://s2.loli.net/2022/05/24/RVdipzncq6MJOPD.png" alt="image-20220524221835190"></p><p>在空白处按ctrl+F9，输入SEQ seq \c。剪切这部分，点击ctrl+h，进入替换页面。把^d STYLEREF 1\s替换为剪切的部分。</p><p><img src="https://s2.loli.net/2022/05/24/iQblfeqks2tZV3D.png" alt="image-20220524222056969"></p><p>按Alt + F9退出域，ctrl+A全选，按F9刷新即可完成。</p><p>Tips：建议写完所有论文之后再设置这个图注。</p><p>表格和图片引用是一样的，这里不赘诉了。</p><p>设计一个好看的表结构：</p><p>插入表格，进入表格设计，右击表格点击新建表格样式，选择古典型1</p><p><img src="https://s2.loli.net/2022/05/24/nRat5yObDC6HAWp.png" alt="image-20220524222645757"></p><p>设置字体：和正文一样。</p><p>设置格式：首先在将格式应用于首列，在框线出取消右框线，再选择应用于首行，把字体改成不倾斜即可。</p><p><img src="https://s2.loli.net/2022/05/24/lBqOwHpQmbuxjFr.png" alt="image-20220524223029002"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;优雅搞定word论文模板&lt;/h1&gt;
&lt;h3 id=&quot;Q：怎么修改默认标题字体&quot;&gt;Q：怎么修改默认标题字体&lt;/h3&gt;
&lt;h3 id=&quot;A：右键点击修改。&quot;&gt;A：右键点击修改。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/24/</summary>
      
    
    
    
    <category term="论文模板" scheme="https://qzl.luoxiaohei.fun/categories/%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
    
    
    <category term="论文模板" scheme="https://qzl.luoxiaohei.fun/tags/%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>性爱课堂 -- 深田老师</title>
    <link href="https://qzl.luoxiaohei.fun/posts/cd909dd0.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/cd909dd0.html</id>
    <published>2023-06-07T02:41:42.222Z</published>
    <updated>2023-06-08T05:27:56.044Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5fba2ad0f7bd52aaa36fb39004047762c8518bab62cdd93cc5f9ac34c0a91760">c74f710743701036f7d1284969e87da53b8fad0bf46163e92b693e1a16ae7704b10bc776e0dc55bdb395d6c654e05f862fc56addc81ad4fe62eb2312aa2c45badd71d067e3d480e6ed9be8aafd0c6650f193f7ecf4d2a6aac47671680e396a24bb39f18a430221109aec97b6e1383c0b8016f79f6d1d19f130035a2bdae8ebd4e7f598ca90a498990031ef299b06a0bc4d287c37166156675574d108a45ed2f4ea8be1ab2d911fda3b551644bf2ef6c0035cbd181fecbb520be9bb8b1fc306d9052feec5871683e4315fd60af0789032d1d2f4510c3f6f8c553b65847839cad4e701b318b3f1100a8b22a64103fb270208b3a81ead878140db9fe4f480ff6b4d52a68f16493c8e86d8143ca34ba71947b0b3310a6816ca2cdf0277218c6c25737591401043d4d42f82159dab3fd81754c76e3b737ca5d72954e7458ec0e64040954b426fd5fb9b7cd3db0bd8ef13cd6e3b83eccbe4e0387c8451f363ea15b0e8d2c7a34cfe92477958d8a08180e1a60c0a7ee4c294ef6dc41c66b5e38f51abceffd43755c899414f28ee7d59a30f3c082dd89cf0b96dd3871d6d45b17182e552c5d3f84a95a848998bbdfc505ee4c4dc17bcac87c45005477e522957223363642759efa5aa38b4040eb09f90565c4303c29f49fd619bd8d894b9e88f08a05414e830e12f733b244160e31943aedf0ee2ab22608c913528b78f7f3b28ee3e684c9dea5392e0c9beefd0aaa3fd4e704aa7b711d02c0c74d8a8bd22584da830c7632a45087812cd1356668a81b6e0e2bec89c9ac057a4577f9c528c01819ba7ff4b6ccd987f31dbb88141e5016000566b3284694a47e0b2aae27d3e5abfea80645d9d280605c4302d6036f8ce8c40ab94a27f054069dfd46566341edb50fb603929c56ee27e1c6a1caa93505715813181f1e4d0eea6b09b87dd1a57bd5c79e675ea0dc1aace2211126da48363335a8ddd7bba1248fc5cbe7d9e91da09839b96aaa459fb61fb59632806028ec61e53527ba715216ed8006d0abac06e18f30de3af0f5c671facaac8d62b7c597b2c48169a54898ac8467a3d538739a4f7367f3a3dcae6a2eb91f4150074c6ee9bdd26da8c3e26bfced270bd60ccdf65db46fa81f9a7a5850cd1bf6bfd0c02380d471b9690f906d368b0224cc2fd1456a28e462f01128d4b97c638828ccfc42754acfcb5a9022537fdddf92f9c1615842a27d97e0cad998f01a69d0934076cb9aefb7facc66f226c62ecd0aca9270b260738655d99f1c8a374f2a17a2edb2345bdb4b7d25fd437807438a31d9442afcf0ccd24c9fbff00c747be229d668e0aba0f0d65cd7974edfb0c101588f522f622b9c8fd4f46a75e3bd878c3a26585f5d0ee0bb9e367812d53185d1c8f15374aa4d10296ae4d9931a97905b742f79375f53141ccbf577ec4f46e16d822bedd6a9d71a8e2d9e1ec73d6f6fe74b11a377345cee345190e448b0f34358736d2d98c745c78a3fc360dbeffc8fa42fab0e9cb348428c8cd422ee71ba3f3fa0f6f73d70602992671bc6d838e1c3ee1b88e51678f0e9f711071631d946f458f93bf8f0c043d936db50b88680c9fb5f7b1c829e58c4814cd2f4ecb801af6b926dc776f56fac6360c0dd51dbfd5449bbeedaae629288db1a9d51bcdf2006a2242b25aff1b97a24815f1a31b94d82a8f8e2b6eb2172e1c2b1cff7aa98d01cd4ba87d266a3f55b2ba738a38adce37a154b14d884f91f7255565eab482a0ce807d4375765c16e1291a5e5576c63072bb64874afd61e606ff0acc3255fdf0fb63911e2cb3665d3b26b319f5c9107799a5a09854e8ba3f6811178b70814acb44fefbe2bde7230d366bc4ffccefd0c49929e8a4be67ec83a782d873c4f6cb84108e72f4c4b5bcb1debcdc154cfd381dce0ce50f81d839f52b442f758a94bba2b844dc96d5ef8d0367b81db44aa36fa4e8f9548af0b317a0b8ad1117047e4f6c138e6ae7328ad9f41a7cf9d4bc9882ecff4255efabe95c44fb35909c118af684ce4f926311554e332adf33e3959a25f7b17229d2698504d1b16f3309b486789d61037214087db5e07465dcb5c3dc135f8af64dc9d011ef85f2bb021ef1d3db18f62b0db9bb54a1d9c816e38157db7e8ada3ecbef99f74d17183980da709830c5b0d64322b75818eccfb3fad9b65416bce12684e15b1feb7e717916cce19a1a97d14d017590730901cb7506151209f904b27e8648feff8a5e0fa748228b20fdedc82e3a9d8cda6b3a694757f302c0be</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">比较sex的东西，需要密码才能进入!</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">想看联系站长哟!</summary>
    
    
    
    <category term="性" scheme="https://qzl.luoxiaohei.fun/categories/%E6%80%A7/"/>
    
    
    <category term="性" scheme="https://qzl.luoxiaohei.fun/tags/%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>力扣hot100--003</title>
    <link href="https://qzl.luoxiaohei.fun/posts/fab21809.html"/>
    <id>https://qzl.luoxiaohei.fun/posts/fab21809.html</id>
    <published>2023-06-07T02:41:42.208Z</published>
    <updated>2023-06-07T03:00:16.566Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>📖每日更新一道力扣hot100</p></div><div class="note success flat"><p>📚更新于5.18</p></div><hr><h1>3. 无重复字符的最长子串</h1><h2 id="题目描述">题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="实例">实例</h2><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><h2 id="示例2：">示例2：</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><h2 id="示例3：">示例3：</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line">你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="解题思路：">解题思路：</h2><p>查找子串首先想到<strong>移动窗口</strong>，设置开始和结束指针，在字符串中，随着结束指针往后移动，若一直不出现相同的字符，则字符串的长度就是最长子串，但遇到相同的字符，则需要将开始指针指向相同字符所在位置的下一个字符，更新最大子串的长度。更新最长子串的长度要保留被淘汰掉的子串，所以用max（）函数进行比较，保留最长的子串长度。如图所示：</p><p><strong>时间空间复杂度</strong>：O（n^2)、O(1)</p><p><img src="https://s2.loli.net/2022/05/29/FTylHzDCAmrBkbQ.png" alt="image-20220529135837645"></p><h2 id="代码实现：">代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">result</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">end</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmpChar=s[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index = start; index &lt; end; index++)<span class="comment">//查找可以用hashmap优化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpChar == s[index])</span><br><span class="line">            &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">                length = end - start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result=<span class="built_in">max</span>(result,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为遍历字符串过程中，都需要用for语句判断子串中是否有相同字符出现，所以时间复杂度到了n^2。用hash表的快速查找方法，可以降低一个数量级的时间复杂度。</p><h2 id="代码实现：-2">代码实现：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">result</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">start</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">end</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> tmpChar=s[end];</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">find</span>(tmpChar) != p.<span class="built_in">end</span>() &amp;&amp; p[tmpChar] &gt;=start)&#123; <span class="comment">//返回迭代器--是一个对象，作用是是遍历选择序列中的对象</span></span><br><span class="line">            <span class="comment">//p.find(tmpChar) != p.end()表示返回的两个迭代器不相等子串中找到了重复的元素。</span></span><br><span class="line">            <span class="comment">//p[tmpChar] &gt;=start 用于避免查到到之前匹配的子串，因为hash不会表中的内容一直在。想象一个hash表，里面存了（a，1）但是start已经因为其他元素更新到2了，这时候通过 int tmpChar=s[end]--p[tmpChar]匹配到的元素确实（a，1）,这是不正确的。</span></span><br><span class="line">            start = p[tmpChar]+<span class="number">1</span>;</span><br><span class="line">            length = end-start;</span><br><span class="line">        &#125;</span><br><span class="line">        p[tmpChar]=end;</span><br><span class="line">        <span class="comment">//p.insert(Mymap::value_type(&#x27;tmpChar&#x27;, end));</span></span><br><span class="line">        end++;</span><br><span class="line">        length++;</span><br><span class="line">        result=<span class="built_in">max</span>(result,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结：">总结：</h2><p>还有一个用数捅的方法代替hash，本文不做深究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;📖每日更新一道力扣hot100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note success flat&quot;&gt;&lt;p&gt;📚更新于5.18&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h1&gt;3. 无重复字符的最长子串&lt;/h1</summary>
      
    
    
    
    <category term="算法题" scheme="https://qzl.luoxiaohei.fun/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
    <category term="c++、算法" scheme="https://qzl.luoxiaohei.fun/tags/c-%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
